package edu.fhda.argos;

import com.google.common.io.ByteStreams;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLEncoder;
import java.util.HashMap;
import java.util.Iterator;

/**
 * The ArgosV3Report class collects all of the necessary elements need to successfully execute a report using Evisions
 * Argos 3.x into one place.
 * <p/>
 * By design, a single API call to the Argos MAPS server will both execute the report, and return the completed result
 * in the request format. This class goes a step further and breaks that process down into two smaller steps. The intent
 * here is specifically to accomodate web applications that implement a dynamic UI with AJAX. If you call the API
 * service directly, you run the risk of the browser making decisions that the user may not appreciate; such as auto-displaying
 * a completed report in the Adobe PDF browser add-on in such a way that the user is re-directed away from your application.
 * <p/>
 * The single service call is also not event based, and in a web application setting, not having events to drive widgets
 * or alerts makes UI design a bit more challenging. Using this class, you can wrap web services around two discreet steps
 * to executing a report: (1) running the actual report to completion, and (2) the downloading of the finished result.
 *
 * @version 1.0
 * @author Matt Rapczynski
 */
public class ArgosV3Report {

    /** Indicates that the executed report should be returned as an Adobe PDF document. */
    public static String FORMAT_PDF = "PDF";
    /** Indicates that the executed report should be returned as a Microsoft Excel (XLS) spreadsheet. */
    public static String FORMAT_EXCEL = "XLS";
    /** Indicates that the executed report should be returned a text-based comma delimited format. */
    public static String FORMAT_CSV = "CSV";
    /** Indicates that the executed report should be returned as plain text. */
    public static String FORMAT_TXT = "TXT";
    /** Indicates that the executed report should be returned as a formatted HTML document. */
    public static String FORMAT_HTML = "HTML";
    
    private String apiKey = null;
    private String format = FORMAT_PDF;
    private String username = null;
    private String password = null;

    private URL maps_api_url = null;
    private URL maps_report_url = null;

    private int readTimeout = 120;
    private String maps_api_referrer = null;
    private String maps_http_response = null;
    private int maps_http_response_code;
    private byte[] finished_report;

    private HashMap<String, String> parameters = new HashMap<String, String>();

    /**
     * Allocates a new ArgosV3Report that executes the report assigned to the provided API key.
     * @param reportAPIKey String containing the entire API key generated by Argos via the "Edit Report" dialog.
     */
    public ArgosV3Report(String reportAPIKey) {
        // Initialize API field from provided parameter
        this.apiKey = reportAPIKey;
    }

    /**
     * Get the API key assigned to this report object.
     * @return The API key as a String.
     */
    public String getAPIKey() {
        return apiKey;
    }

    /**
     * Get the report format configured for this report object.
     * @return Report format as a String.
     */
    public String getReportFormat() {
        return format;
    }

    /**
     * Assign a new format to this report object.
     * @param format String describing the format to use. It is recommended that you stick to the pre-defined formats in this class. Argos will reject formats it does not support.
     */
    public void setReportFormat(String format) {
        this.format = format;
    }

    /**
     * Get the username assigned to this report object to authenticate with Argos.
     * @return A String containing the current user, or null if unset.
     */
    public String getUsername() {
        return username;
    }

    /**
     * Set the username to be used for Argos authentication when the report is executed.
     * @param username A String representing the username.
     */
    public void setUsername(String username) {
        this.username = username;
    }

    /**
     * Get the password assigned to this report object to authenticate with Argos.
     * @return A String containing the current password, or null if unset.
     */
    public String getPassword() {
        return password;
    }

    /**
     * Set the password to be used for Argos authentication when the report is executed.
     * @param password A String representing the password.
     */
    public void setPassword(String password) {
        this.password = password;
    }

    /**
     * Get the currently configured URL for the Argos/MAPS Platform server.
     * @return java.net.URL for the MAPS platform URL, or null if unset.
     */
    public URL getMAPSServer() {
        return maps_api_url;
    }

    /**
     * Set the URL for the Argos/MAPS Platform server (from String).
     * @param newURL A String representing the URL for the MAPS server. Will be wrapped into a java.net.URL object.
     * @throws MalformedURLException If the supplied URL cannot be correctly parsed
     */
    public void setMAPSServer(String newURL) throws MalformedURLException {
        this.maps_api_url = new URL(newURL);
    }

    /**
     * Set the URL for the Argos/MAPS Platform server (from existing URL object).
     * @param newURLobj A java.net.URL object represent the URL for the MAPS server.
     */
    public void setMAPSServer(URL newURLobj) {
        this.maps_api_url =  newURLobj;
    }

    /**
     * Get the currently configured HTTP referer URL for the Argos/MAPS Platform server.
     * @return The current referer URL as a String, or null if unset.
     */
    public String getMAPSReferrer() {
        return maps_api_referrer;
    }

    /**
     * Set the HTTP referer URL for the Argos/MAPS Platform server. See the Argos Report Designers reference, or MAPS Administration reference, for more detail.
     * @param newRefererURL A String representing the referer URL to be used for report execution.
     */
    public void setMAPSReferrer(String newRefererURL) {
        this.maps_api_referrer = newRefererURL;
    }

    /**
     * Get the response body following the execution of a report. If execution was successful, then typically this will remain blank. If there
     * was an error while trying to run the report, then the information sent back by Argos will be stored here.
     * @return  A String representing the reply from Argos if needed, or null if unused.
     */
    public String getHTTPResponse() {
        return maps_http_response;
    }

    /**
     * Get the HTTP status/reply code from the last request to the MAPS server from this report reference (could be execution, or downloading).
     * @return Int value specifying the HTTP status code.
     */
    public int getHTTPResponseCode() {
        return maps_http_response_code;
    }

    /**
     * Get the URL to the completed report following successful execution
     * @return String value representing the direct download URL to the finished report
     */
    public URL getMAPSReportURL() {
        return maps_report_url;
    }

    /**
     * Add parameter/variable to the report to be sent along with the execution request. These variables are to directly
     * correspond with the variables created in the data block. See the "Edit Report", "API" tab for more detail.
     * @param variableName The name of the parameter/variable as a String.
     * @param variableValue The value to assign to the parameter/variable as a String.
     */
    public void addParameter(String variableName, String variableValue) {
        // Add to parameter collection
        parameters.put(variableName, variableValue);
    }

    /**
     * Remove a parameter from the internal variable map used for report execution.
     * @param variableName Name of the variable to remove.
     */
    public void removeParameter(String variableName) {
        // Remove from parameter collection
        parameters.remove(variableName);
    }

    /**
     * Get a byte[] array of raw data representing a successfully downloaded report file.
     * @return Report file as byte[].
     */
    public byte[] getFinishedReport() {
        return finished_report;
    }

    /**
     * Get the currently configuration network read timeout value in seconds. Defaults to 2 minutes if unchanged.
     * @return Int value of seconds to wait before timing out.
     */
    public int getReadTimeout() {
        return readTimeout;
    }

    /**
     * Set a new network read timeout value to override the default. Defaults to 2 minutes if unchanged.
     * @param readTimeout New Int value of seconds to wait for network activity from the MAPS server.
     */
    public void setReadTimeout(int readTimeout) {
        this.readTimeout = readTimeout;
    }

    /**
     * Build a complete, encoded string of all parameters (including necessary MAPS configuration) to be sent in the
     * request body for report execution. For format details, see reference on MIME type: application/x-www-form-urlencoded
     * @return String value representing a complete set of encoded values intended for consumption by the MAPS server
     * @throws UnsupportedEncodingException
     */
    protected String encodeParameters() throws UnsupportedEncodingException {
        // Mutable string for the HTTP request body
        StringBuilder encodedParamBody = new StringBuilder();

        // Setup the API key, and report format
        encodedParamBody.append("report=" + this.getAPIKey() + "&");
        encodedParamBody.append("format=" + this.getReportFormat() + "&");

        // Setup optional configuration (username, password, etc...)
        if(this.username != null && this.password != null) {
            encodedParamBody.append("username=" + URLEncoder.encode(this.username, "UTF-8") + "&");
            encodedParamBody.append("password=" + URLEncoder.encode(this.password, "UTF-8") + "&");
        }

        // Iterate through the report parameters/variables, encode, and append
        Iterator<String> varNames = parameters.keySet().iterator();
        while(varNames.hasNext()) {
            String varName = varNames.next();
            if(varNames.hasNext()) {
                encodedParamBody.append(varName + "=" + URLEncoder.encode(parameters.get(varName), "UTF-8") + "&");
            } else {
                encodedParamBody.append(varName + "=" + URLEncoder.encode(parameters.get(varName), "UTF-8"));
            }
        }

        // Done
        return encodedParamBody.toString();
    }

    /**
     * Build an HTTP POST request representing the report to be executed, and send it off to the MAPS server
     * to be filled. Java standard java.net.HTTPURLConnection is used for the network communication.
     * @throws IOException
     * @throws MAPSException If the MAPS returns other than HTTP status 200 or 302.
     * @throws InvalidReportException If any problems are identified when validating the report prior to building the HTTP request.
     */
    public void executeReport() throws IOException, MAPSException, InvalidReportException {
        // Validate report configuration
        // Check for obvious stuff like MAPS configuration, report type, etc...
        if(format == null) {
            throw new InvalidReportException("Missing report format; hint: setFormat(...)");
        }
        else if(maps_api_url == null) {
            throw new InvalidReportException("Missing MAPS server URL; hint: setMAPSServer(...)");
        }
        else if(maps_api_referrer == null) {
            throw new InvalidReportException("Missing MAPS referer security URL; hint: setMAPSReferrer(...)");
        }

        // Encode the parameters
        String encRequestBody = this.encodeParameters();

        // Create and configure the HTTP connection
        HttpURLConnection mapsServer = (HttpURLConnection) this.getMAPSServer().openConnection();
        mapsServer.setInstanceFollowRedirects(false);
        mapsServer.setRequestMethod("POST");
        mapsServer.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
        mapsServer.setRequestProperty("Content-Length", Integer.toString(encRequestBody.getBytes().length));
        mapsServer.setRequestProperty("Referer", this.maps_api_referrer);
        mapsServer.setUseCaches(false);
        mapsServer.setReadTimeout(this.readTimeout * 1000);
        mapsServer.setDoInput(true);
        mapsServer.setDoOutput(true);
        mapsServer.connect();

        // Write request body and complete
        DataOutputStream mapsOut = new DataOutputStream(mapsServer.getOutputStream());
        mapsOut.writeBytes(encRequestBody);
        mapsOut.flush();
        mapsOut.close();

        // Get HTTP information
        this.maps_http_response_code = mapsServer.getResponseCode();

        // Read MAPS response body
        ByteArrayOutputStream mapsIn = new ByteArrayOutputStream();
        // Did the request succeed?
        if(this.maps_http_response_code == 200 || this.maps_http_response_code == 302) {
            // Save the URL for the finished file
            this.maps_report_url = new URL(mapsServer.getHeaderField("Location"));
        }
        // Else request likely ended in an error; capture the message from MAPS, and throw an exception to the caller
        else {
            ByteStreams.copy(mapsServer.getErrorStream(), mapsIn);
            throw new MAPSException(new String(mapsIn.toString()), this.maps_http_response_code);
        }
        this.maps_http_response = new String(mapsIn.toString());

        // Clean up
        mapsServer.disconnect();
    }

    /**
     * Build an HTTP GET request to fetch the completed report as indicated by the URL returned from MAPS server
     * following successful execution. Java standard java.net.HTTPURLConnection is used for the network communication.
     * @return
     * @throws IOException
     * @throws MAPSException If the MAPS returns other than HTTP status 200.
     * @throws InvalidReportException If it appears that the report was not executed, or had a problem.
     */
    public byte[] downloadReport() throws IOException, MAPSException, InvalidReportException {
        // Validate
        if(this.maps_report_url == null) {
            throw new InvalidReportException("Invalid report URL. Ensure report is first executed successfully before attempting to download.");
        }

        // Create and configure the HTTP connection
        HttpURLConnection mapsServer = (HttpURLConnection) this.getMAPSReportURL().openConnection();
        mapsServer.setRequestMethod("GET");
        mapsServer.setUseCaches(false);
        mapsServer.setReadTimeout(this.readTimeout * 1000);
        mapsServer.setDoOutput(true);
        mapsServer.connect();

        // Get HTTP information
        this.maps_http_response_code = mapsServer.getResponseCode();

        // Download the report to a temporary buffer
        ByteArrayOutputStream mapsIn = new ByteArrayOutputStream();
        // Did the request succeed?
        if(this.maps_http_response_code == 200) {
            // Save the file data
            ByteStreams.copy(mapsServer.getInputStream(), mapsIn);
        }
        // Else request likely ended in an error; capture the message from MAPS, and throw an exception to the caller
        else {
            ByteStreams.copy(mapsServer.getErrorStream(), mapsIn);
            throw new MAPSException(new String(mapsIn.toString()), this.maps_http_response_code);
        }
        this.maps_http_response = new String(mapsIn.toString());

        // Clean up
        mapsServer.disconnect();
        finished_report = mapsIn.toByteArray();
        return finished_report;
    }
}
